var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { loop, isLoop, getCmd, getModel } from './loop';
import Cmd from './cmd';

var defaultAccessor = function defaultAccessor(state, key) {
  return state[key];
};

var defaultMutator = function defaultMutator(state, key, value) {
  return _extends({}, state, _defineProperty({}, key, value));
};

//TODO: change to be implemented using mergeChildReducers in 5.0
// export default function combineReducers(childMap){
//   return (rootState = {}, action) => {
//     return mergeChildReducers(rootState, action, childMap);
//   };
// }

export var combineReducers = function combineReducers(reducerMap, rootState, accessor, mutator) {
  if (accessor || mutator || rootState) {
    console.warn('Passing customization parameters to combineReducers is deprecated. They will be removed in 5.0. \n      Integrations with popular libraries are being broken out into separate libraries. \n      Please see https://github.com/redux-loop/redux-loop/releases/tag/v4.2.0 for more details.');
  }
  rootState = rootState || {};
  accessor = accessor || defaultAccessor;
  mutator = mutator || defaultMutator;

  return function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : rootState;
    var action = arguments[1];

    var hasChanged = false;
    var cmds = [];

    var model = Object.keys(reducerMap).reduce(function (model, key) {
      var reducer = reducerMap[key];
      var previousStateForKey = accessor(state, key);
      var nextStateForKey = reducer(previousStateForKey, action);

      if (isLoop(nextStateForKey)) {
        cmds.push(getCmd(nextStateForKey));
        nextStateForKey = getModel(nextStateForKey);
      }

      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
      return mutator(model, key, nextStateForKey);
    }, rootState);

    return loop(hasChanged ? model : state, Cmd.list(cmds, { batch: true }) //todo: remove batch in 5.0
    );
  };
};