var _Object$freeze3;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

import { throwInvariant, flatten, isPromiseLike } from './utils';

var isCmdSymbol = Symbol('isCmd');
var dispatchSymbol = Symbol('dispatch');
var getStateSymbol = Symbol('getState');

var cmdTypes = {
  RUN: 'RUN',
  ACTION: 'ACTION',
  LIST: 'LIST',
  MAP: 'MAP',
  NONE: 'NONE'
};

export var isCmd = function isCmd(object) {
  return object ? !!object[isCmdSymbol] : false;
};

function getMappedCmdArgs() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var dispatch = arguments[1];
  var getState = arguments[2];

  return args.map(function (arg) {
    if (arg === dispatchSymbol) return dispatch;else if (arg === getStateSymbol) return getState;else return arg;
  });
}

function handleRunCmd(cmd, dispatch, getState) {
  var onSuccess = cmd.successActionCreator || function () {},
      onFail = cmd.failActionCreator || function () {};

  try {
    var result = cmd.func.apply(cmd, _toConsumableArray(getMappedCmdArgs(cmd.args, dispatch, getState)));

    if (isPromiseLike(result) && !cmd.forceSync) {
      return result.then(onSuccess, onFail).then(function (action) {
        return action ? [action] : [];
      });
    }
    var resultAction = onSuccess(result);
    return resultAction ? Promise.resolve([resultAction]) : null;
  } catch (err) {
    if (!cmd.failActionCreator) {
      console.error(err);
      throw err; //don't swallow errors if they are not handling them
    }
    var _resultAction = onFail(err);
    return _resultAction ? Promise.resolve([_resultAction]) : null;
  }
}

function handleParallelList(_ref, dispatch, getState) {
  var cmds = _ref.cmds,
      _ref$batch = _ref.batch,
      batch = _ref$batch === undefined ? false : _ref$batch;

  var promises = cmds.map(function (nestedCmd) {
    var possiblePromise = executeCmd(nestedCmd, dispatch, getState);
    if (!possiblePromise || batch) {
      return possiblePromise;
    }

    return possiblePromise.then(function (result) {
      return Promise.all(result.map(function (a) {
        return dispatch(a);
      }));
    });
  }).filter(function (x) {
    return x;
  });

  if (promises.length === 0) {
    return null;
  }

  return Promise.all(promises).then(flatten).then(function (actions) {
    return batch ? actions : [];
  });
}

function handleSequenceList(_ref2, dispatch, getState) {
  var cmds = _ref2.cmds,
      _ref2$batch = _ref2.batch,
      batch = _ref2$batch === undefined ? false : _ref2$batch;

  var firstCmd = cmds.length ? cmds[0] : null;
  if (!firstCmd) {
    return null;
  }

  var result = new Promise(function (resolve) {
    var firstPromise = executeCmd(firstCmd, dispatch, getState);
    firstPromise = firstPromise || Promise.resolve([]);
    firstPromise.then(function (result) {
      var executePromise = void 0;
      if (!batch) {
        executePromise = Promise.all(result.map(function (a) {
          return dispatch(a);
        }));
      } else {
        executePromise = Promise.resolve();
      }
      executePromise.then(function () {
        var remainingSequence = list(cmds.slice(1), { batch: batch, sequence: true });
        var remainingPromise = executeCmd(remainingSequence, dispatch, getState);
        if (remainingPromise) {
          remainingPromise.then(function (innerResult) {
            resolve(result.concat(innerResult));
          });
        } else {
          resolve(result);
        }
      });
    });
  }).then(flatten);

  return batch ? result : result.then(function () {
    return [];
  });
}

export var executeCmd = function executeCmd(cmd, dispatch, getState) {
  switch (cmd.type) {
    case cmdTypes.RUN:
      return handleRunCmd(cmd, dispatch, getState);

    case cmdTypes.ACTION:
      return Promise.resolve([cmd.actionToDispatch]);

    case cmdTypes.LIST:
      return cmd.sequence ? handleSequenceList(cmd, dispatch, getState) : handleParallelList(cmd, dispatch, getState);

    case cmdTypes.MAP:
      var possiblePromise = executeCmd(cmd.nestedCmd, dispatch, getState);
      if (!possiblePromise) return null;
      return possiblePromise.then(function (actions) {
        return actions.map(function (action) {
          return cmd.tagger.apply(cmd, _toConsumableArray(cmd.args).concat([action]));
        });
      });

    case cmdTypes.NONE:
      return null;

    default:
      throw new Error('Invalid Cmd type ' + cmd.type);
  }
};

function simulateRun(_ref3) {
  var result = _ref3.result,
      success = _ref3.success;

  if (success && this.successActionCreator) {
    return this.successActionCreator(result);
  } else if (!success && this.failActionCreator) {
    return this.failActionCreator(result);
  }
  return null;
}

var run = function run(func) {
  var _extends2;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (process.env.NODE_ENV !== 'production') {
    if (!options.testInvariants) {
      throwInvariant(typeof func === 'function', 'Cmd.run: first argument to Cmd.run must be a function');

      throwInvariant((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object', 'Cmd.run: second argument to Cmd.run must be an options object');

      throwInvariant(!options.successActionCreator || typeof options.successActionCreator === 'function', 'Cmd.run: successActionCreator option must be a function if specified');

      throwInvariant(!options.failActionCreator || typeof options.failActionCreator === 'function', 'Cmd.run: failActionCreator option must be a function if specified');

      throwInvariant(!options.args || options.args.constructor === Array, 'Cmd.run: args option must be an array if specified');
    }
  } else if (options.testInvariants) {
    throw Error('Redux Loop: Detected usage of Cmd.run\'s testInvariants option in production code. This should only be used in tests.');
  }

  var testInvariants = options.testInvariants,
      rest = _objectWithoutProperties(options, ['testInvariants']);

  return Object.freeze(_extends((_extends2 = {}, _defineProperty(_extends2, isCmdSymbol, true), _defineProperty(_extends2, 'type', cmdTypes.RUN), _defineProperty(_extends2, 'func', func), _defineProperty(_extends2, 'simulate', simulateRun), _extends2), rest));
};

function simulateAction() {
  return this.actionToDispatch;
}

var action = function action(actionToDispatch) {
  var _Object$freeze;

  if (process.env.NODE_ENV !== 'production') {
    throwInvariant((typeof actionToDispatch === 'undefined' ? 'undefined' : _typeof(actionToDispatch)) === 'object' && actionToDispatch !== null && typeof actionToDispatch.type !== 'undefined', 'Cmd.action: first argument and only argument to Cmd.action must be an action');
  }

  return Object.freeze((_Object$freeze = {}, _defineProperty(_Object$freeze, isCmdSymbol, true), _defineProperty(_Object$freeze, 'type', cmdTypes.ACTION), _defineProperty(_Object$freeze, 'actionToDispatch', actionToDispatch), _defineProperty(_Object$freeze, 'simulate', simulateAction), _Object$freeze));
};

function simulateList(simulations) {
  return flatten(this.cmds.map(function (cmd, i) {
    return cmd.simulate(simulations[i]);
  }).filter(function (a) {
    return a;
  }));
}

var list = function list(cmds) {
  var _extends3;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (process.env.NODE_ENV !== 'production') {
    if (!options.testInvariants) {
      throwInvariant(Array.isArray(cmds) && cmds.every(isCmd), 'Cmd.list: first argument to Cmd.list must be an array of other Cmds');

      throwInvariant((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object', 'Cmd.list: second argument to Cmd.list must be an options object');
    }
  } else if (options.testInvariants) {
    throw Error('Redux Loop: Detected usage of Cmd.list\'s testInvariants option in production code. This should only be used in tests.');
  }

  var testInvariants = options.testInvariants,
      rest = _objectWithoutProperties(options, ['testInvariants']);

  return Object.freeze(_extends((_extends3 = {}, _defineProperty(_extends3, isCmdSymbol, true), _defineProperty(_extends3, 'type', cmdTypes.LIST), _defineProperty(_extends3, 'cmds', cmds), _defineProperty(_extends3, 'simulate', simulateList), _extends3), rest));
};

var batch = function batch(cmds) {
  if (process.env.NODE_ENV !== 'production') {
    throwInvariant(Array.isArray(cmds) && cmds.every(isCmd), 'Cmd.batch: first and only argument to Cmd.batch must be an array of other Cmds');
  }

  console.warn('Cmd.batch is deprecated and will be removed in version 5. Please use Cmd.list (https://github.com/redux-loop/redux-loop/blob/master/docs/ApiDocs.md#cmdlistcmds-options)');
  return list(cmds, { batch: true, sequence: false });
};

var sequence = function sequence(cmds) {
  if (process.env.NODE_ENV !== 'production') {
    throwInvariant(Array.isArray(cmds) && cmds.every(isCmd), 'Cmd.sequence: first and only argument to Cmd.sequence must be an array of other Cmds');
  }

  console.warn('Cmd.sequence is deprecated and will be removed in version 5. Please use Cmd.list (https://github.com/redux-loop/redux-loop/blob/master/docs/ApiDocs.md#cmdlistcmds-options)');
  return list(cmds, { batch: true, sequence: true });
};

function simulateMap(simulation) {
  var _this = this;

  var result = this.nestedCmd.simulate(simulation);
  if (Array.isArray(result)) {
    return result.map(function (action) {
      return _this.tagger.apply(_this, _toConsumableArray(_this.args).concat([action]));
    });
  } else if (result) {
    return this.tagger.apply(this, _toConsumableArray(this.args).concat([result]));
  } else {
    return null;
  }
}

var map = function map(nestedCmd, tagger) {
  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var _Object$freeze2;

  if (process.env.NODE_ENV !== 'production') {
    throwInvariant(isCmd(nestedCmd), 'Cmd.map: first argument to Cmd.map must be another Cmd');

    throwInvariant(typeof tagger === 'function', 'Cmd.map: second argument to Cmd.map must be a function that returns an action');
  }

  return Object.freeze((_Object$freeze2 = {}, _defineProperty(_Object$freeze2, isCmdSymbol, true), _defineProperty(_Object$freeze2, 'type', cmdTypes.MAP), _defineProperty(_Object$freeze2, 'tagger', tagger), _defineProperty(_Object$freeze2, 'nestedCmd', nestedCmd), _defineProperty(_Object$freeze2, 'args', args), _defineProperty(_Object$freeze2, 'simulate', simulateMap), _Object$freeze2));
};

var none = Object.freeze((_Object$freeze3 = {}, _defineProperty(_Object$freeze3, isCmdSymbol, true), _defineProperty(_Object$freeze3, 'type', cmdTypes.NONE), _defineProperty(_Object$freeze3, 'simulate', function simulate() {
  return null;
}), _Object$freeze3));

export default {
  run: run,
  action: action,
  list: list,
  batch: batch,
  sequence: sequence,
  map: map,
  none: none,
  dispatch: dispatchSymbol,
  getState: getStateSymbol
};