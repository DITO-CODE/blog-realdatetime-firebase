(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.ReduxLoop = {})));
}(this, (function (exports) { 'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();













var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};













var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};







var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var concat = Array.prototype.concat;

var flatten = function flatten(array) {
  return concat.apply([], array);
};

var throwInvariant = function throwInvariant(condition, message) {
  if (!condition) {
    throw Error(message);
  }
};

var isPromiseLike = function isPromiseLike(obj) {
  return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.then === 'function';
};

var _Object$freeze3;

var isCmdSymbol = Symbol('isCmd');
var dispatchSymbol = Symbol('dispatch');
var getStateSymbol = Symbol('getState');

var cmdTypes = {
  RUN: 'RUN',
  ACTION: 'ACTION',
  LIST: 'LIST',
  MAP: 'MAP',
  NONE: 'NONE'
};

var isCmd = function isCmd(object) {
  return object ? !!object[isCmdSymbol] : false;
};

function getMappedCmdArgs() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var dispatch = arguments[1];
  var getState = arguments[2];

  return args.map(function (arg) {
    if (arg === dispatchSymbol) return dispatch;else if (arg === getStateSymbol) return getState;else return arg;
  });
}

function handleRunCmd(cmd, dispatch, getState) {
  var onSuccess = cmd.successActionCreator || function () {},
      onFail = cmd.failActionCreator || function () {};

  try {
    var result = cmd.func.apply(cmd, toConsumableArray(getMappedCmdArgs(cmd.args, dispatch, getState)));

    if (isPromiseLike(result) && !cmd.forceSync) {
      return result.then(onSuccess, onFail).then(function (action) {
        return action ? [action] : [];
      });
    }
    var resultAction = onSuccess(result);
    return resultAction ? Promise.resolve([resultAction]) : null;
  } catch (err) {
    if (!cmd.failActionCreator) {
      console.error(err);
      throw err; //don't swallow errors if they are not handling them
    }
    var _resultAction = onFail(err);
    return _resultAction ? Promise.resolve([_resultAction]) : null;
  }
}

function handleParallelList(_ref, dispatch, getState) {
  var cmds = _ref.cmds,
      _ref$batch = _ref.batch,
      batch = _ref$batch === undefined ? false : _ref$batch;

  var promises = cmds.map(function (nestedCmd) {
    var possiblePromise = executeCmd(nestedCmd, dispatch, getState);
    if (!possiblePromise || batch) {
      return possiblePromise;
    }

    return possiblePromise.then(function (result) {
      return Promise.all(result.map(function (a) {
        return dispatch(a);
      }));
    });
  }).filter(function (x) {
    return x;
  });

  if (promises.length === 0) {
    return null;
  }

  return Promise.all(promises).then(flatten).then(function (actions) {
    return batch ? actions : [];
  });
}

function handleSequenceList(_ref2, dispatch, getState) {
  var cmds = _ref2.cmds,
      _ref2$batch = _ref2.batch,
      batch = _ref2$batch === undefined ? false : _ref2$batch;

  var firstCmd = cmds.length ? cmds[0] : null;
  if (!firstCmd) {
    return null;
  }

  var result = new Promise(function (resolve) {
    var firstPromise = executeCmd(firstCmd, dispatch, getState);
    firstPromise = firstPromise || Promise.resolve([]);
    firstPromise.then(function (result) {
      var executePromise = void 0;
      if (!batch) {
        executePromise = Promise.all(result.map(function (a) {
          return dispatch(a);
        }));
      } else {
        executePromise = Promise.resolve();
      }
      executePromise.then(function () {
        var remainingSequence = list(cmds.slice(1), { batch: batch, sequence: true });
        var remainingPromise = executeCmd(remainingSequence, dispatch, getState);
        if (remainingPromise) {
          remainingPromise.then(function (innerResult) {
            resolve(result.concat(innerResult));
          });
        } else {
          resolve(result);
        }
      });
    });
  }).then(flatten);

  return batch ? result : result.then(function () {
    return [];
  });
}

var executeCmd = function executeCmd(cmd, dispatch, getState) {
  switch (cmd.type) {
    case cmdTypes.RUN:
      return handleRunCmd(cmd, dispatch, getState);

    case cmdTypes.ACTION:
      return Promise.resolve([cmd.actionToDispatch]);

    case cmdTypes.LIST:
      return cmd.sequence ? handleSequenceList(cmd, dispatch, getState) : handleParallelList(cmd, dispatch, getState);

    case cmdTypes.MAP:
      var possiblePromise = executeCmd(cmd.nestedCmd, dispatch, getState);
      if (!possiblePromise) return null;
      return possiblePromise.then(function (actions) {
        return actions.map(function (action) {
          return cmd.tagger.apply(cmd, toConsumableArray(cmd.args).concat([action]));
        });
      });

    case cmdTypes.NONE:
      return null;

    default:
      throw new Error('Invalid Cmd type ' + cmd.type);
  }
};

function simulateRun(_ref3) {
  var result = _ref3.result,
      success = _ref3.success;

  if (success && this.successActionCreator) {
    return this.successActionCreator(result);
  } else if (!success && this.failActionCreator) {
    return this.failActionCreator(result);
  }
  return null;
}

var run = function run(func) {
  var _babelHelpers$extends;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  {
    if (!options.testInvariants) {
      throwInvariant(typeof func === 'function', 'Cmd.run: first argument to Cmd.run must be a function');

      throwInvariant((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object', 'Cmd.run: second argument to Cmd.run must be an options object');

      throwInvariant(!options.successActionCreator || typeof options.successActionCreator === 'function', 'Cmd.run: successActionCreator option must be a function if specified');

      throwInvariant(!options.failActionCreator || typeof options.failActionCreator === 'function', 'Cmd.run: failActionCreator option must be a function if specified');

      throwInvariant(!options.args || options.args.constructor === Array, 'Cmd.run: args option must be an array if specified');
    }
  }

  var testInvariants = options.testInvariants,
      rest = objectWithoutProperties(options, ['testInvariants']);


  return Object.freeze(_extends((_babelHelpers$extends = {}, defineProperty(_babelHelpers$extends, isCmdSymbol, true), defineProperty(_babelHelpers$extends, 'type', cmdTypes.RUN), defineProperty(_babelHelpers$extends, 'func', func), defineProperty(_babelHelpers$extends, 'simulate', simulateRun), _babelHelpers$extends), rest));
};

function simulateAction() {
  return this.actionToDispatch;
}

var action = function action(actionToDispatch) {
  var _Object$freeze;

  {
    throwInvariant((typeof actionToDispatch === 'undefined' ? 'undefined' : _typeof(actionToDispatch)) === 'object' && actionToDispatch !== null && typeof actionToDispatch.type !== 'undefined', 'Cmd.action: first argument and only argument to Cmd.action must be an action');
  }

  return Object.freeze((_Object$freeze = {}, defineProperty(_Object$freeze, isCmdSymbol, true), defineProperty(_Object$freeze, 'type', cmdTypes.ACTION), defineProperty(_Object$freeze, 'actionToDispatch', actionToDispatch), defineProperty(_Object$freeze, 'simulate', simulateAction), _Object$freeze));
};

function simulateList(simulations) {
  return flatten(this.cmds.map(function (cmd, i) {
    return cmd.simulate(simulations[i]);
  }).filter(function (a) {
    return a;
  }));
}

var list = function list(cmds) {
  var _babelHelpers$extends2;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  {
    if (!options.testInvariants) {
      throwInvariant(Array.isArray(cmds) && cmds.every(isCmd), 'Cmd.list: first argument to Cmd.list must be an array of other Cmds');

      throwInvariant((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object', 'Cmd.list: second argument to Cmd.list must be an options object');
    }
  }

  var testInvariants = options.testInvariants,
      rest = objectWithoutProperties(options, ['testInvariants']);


  return Object.freeze(_extends((_babelHelpers$extends2 = {}, defineProperty(_babelHelpers$extends2, isCmdSymbol, true), defineProperty(_babelHelpers$extends2, 'type', cmdTypes.LIST), defineProperty(_babelHelpers$extends2, 'cmds', cmds), defineProperty(_babelHelpers$extends2, 'simulate', simulateList), _babelHelpers$extends2), rest));
};

var batch = function batch(cmds) {
  {
    throwInvariant(Array.isArray(cmds) && cmds.every(isCmd), 'Cmd.batch: first and only argument to Cmd.batch must be an array of other Cmds');
  }

  console.warn('Cmd.batch is deprecated and will be removed in version 5. Please use Cmd.list (https://github.com/redux-loop/redux-loop/blob/master/docs/ApiDocs.md#cmdlistcmds-options)');
  return list(cmds, { batch: true, sequence: false });
};

var sequence = function sequence(cmds) {
  {
    throwInvariant(Array.isArray(cmds) && cmds.every(isCmd), 'Cmd.sequence: first and only argument to Cmd.sequence must be an array of other Cmds');
  }

  console.warn('Cmd.sequence is deprecated and will be removed in version 5. Please use Cmd.list (https://github.com/redux-loop/redux-loop/blob/master/docs/ApiDocs.md#cmdlistcmds-options)');
  return list(cmds, { batch: true, sequence: true });
};

function simulateMap(simulation) {
  var _this = this;

  var result = this.nestedCmd.simulate(simulation);
  if (Array.isArray(result)) {
    return result.map(function (action) {
      return _this.tagger.apply(_this, toConsumableArray(_this.args).concat([action]));
    });
  } else if (result) {
    return this.tagger.apply(this, toConsumableArray(this.args).concat([result]));
  } else {
    return null;
  }
}

var map = function map(nestedCmd, tagger) {
  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var _Object$freeze2;

  {
    throwInvariant(isCmd(nestedCmd), 'Cmd.map: first argument to Cmd.map must be another Cmd');

    throwInvariant(typeof tagger === 'function', 'Cmd.map: second argument to Cmd.map must be a function that returns an action');
  }

  return Object.freeze((_Object$freeze2 = {}, defineProperty(_Object$freeze2, isCmdSymbol, true), defineProperty(_Object$freeze2, 'type', cmdTypes.MAP), defineProperty(_Object$freeze2, 'tagger', tagger), defineProperty(_Object$freeze2, 'nestedCmd', nestedCmd), defineProperty(_Object$freeze2, 'args', args), defineProperty(_Object$freeze2, 'simulate', simulateMap), _Object$freeze2));
};

var none = Object.freeze((_Object$freeze3 = {}, defineProperty(_Object$freeze3, isCmdSymbol, true), defineProperty(_Object$freeze3, 'type', cmdTypes.NONE), defineProperty(_Object$freeze3, 'simulate', function simulate() {
  return null;
}), _Object$freeze3));

var Cmd = {
  run: run,
  action: action,
  list: list,
  batch: batch,
  sequence: sequence,
  map: map,
  none: none,
  dispatch: dispatchSymbol,
  getState: getStateSymbol
};

var isLoop = function isLoop(array) {
  return Array.isArray(array) && array.length === 2 && isCmd(array[1]) && !isCmd(array[0]);
};

var getCmd = function getCmd(loop) {
  return isLoop(loop) ? loop[1] : null;
};

var getModel = function getModel(loop) {
  return isLoop(loop) ? loop[0] : loop;
};

var loop = function loop(model, cmd) {
  {
    throwInvariant(isCmd(cmd), 'Given cmd is not an Cmd instance.');
  }

  return [model, cmd];
};

var liftState = function liftState(state) {
  return isLoop(state) ? state : loop(state, Cmd.none);
};

var loopPromiseCaughtError = function loopPromiseCaughtError(originalActionType, error) {
  return "\nException thrown when running Cmds from action: " + originalActionType + ".\n\nThrown exception: \n" + error + "\n";
};

function install() {
  return function (next) {
    return function (reducer, initialState, enhancer) {
      var _liftState = liftState(initialState),
          _liftState2 = slicedToArray(_liftState, 2),
          initialModel = _liftState2[0],
          initialCmd = _liftState2[1];

      var cmdsQueue = [];

      var liftReducer = function liftReducer(reducer) {
        return function (state, action) {
          var result = reducer(state, action);

          var _liftState3 = liftState(result),
              _liftState4 = slicedToArray(_liftState3, 2),
              model = _liftState4[0],
              cmd = _liftState4[1];

          cmdsQueue.push({ originalAction: action, cmd: cmd });
          return model;
        };
      };

      var store = next(liftReducer(reducer), initialModel, enhancer);

      var runCmds = function runCmds(queue) {
        var promises = queue.map(runCmd).filter(function (x) {
          return x;
        });
        if (promises.length === 0) {
          return Promise.resolve();
        } else if (promises.length === 1) {
          return promises[0];
        } else {
          return Promise.all(promises).then(function () {});
        }
      };

      var runCmd = function runCmd(_ref) {
        var originalAction = _ref.originalAction,
            cmd = _ref.cmd;

        var cmdPromise = executeCmd(cmd, dispatch, store.getState);

        if (!cmdPromise) return null;

        return cmdPromise.then(function (actions) {
          if (!actions.length) return;
          return Promise.all(actions.map(dispatch));
        })['catch'](function (error) {
          console.error(loopPromiseCaughtError(originalAction.type, error));
          throw error;
        });
      };

      var dispatch = function dispatch(action) {
        store.dispatch(action);
        var cmdsToRun = cmdsQueue;
        cmdsQueue = [];
        return runCmds(cmdsToRun);
      };

      var replaceReducer = function replaceReducer(reducer) {
        return store.replaceReducer(liftReducer(reducer));
      };

      runCmd({
        originalAction: { type: '@@ReduxLoop/INIT' },
        cmd: initialCmd
      });

      return _extends({}, store, {
        dispatch: dispatch,
        replaceReducer: replaceReducer
      });
    };
  };
}

var defaultAccessor = function defaultAccessor(state, key) {
  return state[key];
};

var defaultMutator = function defaultMutator(state, key, value) {
  return _extends({}, state, defineProperty({}, key, value));
};

//TODO: change to be implemented using mergeChildReducers in 5.0
// export default function combineReducers(childMap){
//   return (rootState = {}, action) => {
//     return mergeChildReducers(rootState, action, childMap);
//   };
// }

var combineReducers = function combineReducers(reducerMap, rootState, accessor, mutator) {
  if (accessor || mutator || rootState) {
    console.warn('Passing customization parameters to combineReducers is deprecated. They will be removed in 5.0. \n      Integrations with popular libraries are being broken out into separate libraries. \n      Please see https://github.com/redux-loop/redux-loop/releases/tag/v4.2.0 for more details.');
  }
  rootState = rootState || {};
  accessor = accessor || defaultAccessor;
  mutator = mutator || defaultMutator;

  return function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : rootState;
    var action = arguments[1];

    var hasChanged = false;
    var cmds = [];

    var model = Object.keys(reducerMap).reduce(function (model, key) {
      var reducer = reducerMap[key];
      var previousStateForKey = accessor(state, key);
      var nextStateForKey = reducer(previousStateForKey, action);

      if (isLoop(nextStateForKey)) {
        cmds.push(getCmd(nextStateForKey));
        nextStateForKey = getModel(nextStateForKey);
      }

      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
      return mutator(model, key, nextStateForKey);
    }, rootState);

    return loop(hasChanged ? model : state, Cmd.list(cmds, { batch: true }) //todo: remove batch in 5.0
    );
  };
};

function mergeChildReducers(parentResult, action, childMap) {
  var initialState = parentResult,
      parentCmd = void 0;
  if (isLoop(initialState)) {
    parentCmd = getCmd(initialState);
    initialState = getModel(initialState);
  }

  var cmds = parentCmd ? [parentCmd] : [];
  var hasChanged = false;

  var newState = Object.keys(childMap).reduce(function (prev, key) {
    var childReducer = childMap[key];
    if (!childReducer) {
      if (!hasChanged) {
        prev = _extends({}, prev);
        hasChanged = true;
      }
      delete prev[key];
      return prev;
    }
    var currentChild = childReducer(prev[key], action);
    if (isLoop(currentChild)) {
      cmds.push(getCmd(currentChild));
      currentChild = getModel(currentChild);
    }

    if (prev[key] !== currentChild && hasChanged) {
      prev[key] = currentChild;
    } else if (prev[key] !== currentChild) {
      prev = _extends({}, prev, defineProperty({}, key, currentChild));
      hasChanged = true;
    }
    return prev;
  }, initialState);

  return loop(newState, getListCmdIfNeeded(cmds));
}

function getListCmdIfNeeded(cmds) {
  switch (cmds.length) {
    case 0:
      return Cmd.none;
    case 1:
      return cmds[0];
    default:
      return Cmd.list(cmds);
  }
}

exports.combineReducers = combineReducers;
exports.mergeChildReducers = mergeChildReducers;
exports.Cmd = Cmd;
exports.install = install;
exports.loop = loop;
exports.liftState = liftState;
exports.getModel = getModel;
exports.getCmd = getCmd;
exports.isLoop = isLoop;

Object.defineProperty(exports, '__esModule', { value: true });

})));
